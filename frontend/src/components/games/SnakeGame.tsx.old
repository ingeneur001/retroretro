import React, { useState, useRef, useEffect, useCallback } from 'react';
import styled, { keyframes, css } from 'styled-components';
import { useGameIntegration } from '../../interfaces/user/UserManager';

// Animationen
const pulse = keyframes`
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); }
`;

const gameGlow = keyframes`
  0%, 100% { box-shadow: 0 0 10px #00ffff; }
  50% { box-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff; }
`;

const scoreGlow = keyframes`
  0%, 100% { text-shadow: 0 0 10px #00ff00; }
  50% { text-shadow: 0 0 20px #00ff00, 0 0 30px #00ff00; }
`;

const gameOver = keyframes`
  0%, 100% { color: #ff0000; text-shadow: 0 0 10px #ff0000; }
  50% { color: #ff6666; text-shadow: 0 0 20px #ff6666, 0 0 30px #ff6666; }
`;

// Styled Components
const SnakeGameContainer = styled.div`
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
  max-width: 900px;
  margin: 2rem auto;
  padding: 20px;
  background: linear-gradient(145deg, #1a1a2e 0%, #16213e 100%);
  border: 2px solid #00ffff;
  border-radius: 15px;
  animation: ${gameGlow} 3s ease-in-out infinite;
`;

const GameTitle = styled.h2`
  color: #00ffff;
  margin-bottom: 15px;
  font-size: 1.8rem;
  text-align: center;
  font-weight: 700;
`;

const GameInfo = styled.div`
  display: flex;
  justify-content: space-around;
  width: 100%;
  max-width: 640px;
  margin: 20px 0;
  gap: 20px;
`;

const InfoCard = styled.div`
  background: rgba(0, 255, 255, 0.1);
  border: 1px solid #00ffff;
  border-radius: 8px;
  padding: 15px 20px;
  text-align: center;
  min-width: 120px;
  
  h4 {
    color: #00ffff;
    margin: 0 0 5px 0;
    font-size: 0.9rem;
    text-transform: uppercase;
  }
  
  span {
    color: #00ff00;
    font-size: 1.8rem;
    font-weight: bold;
    animation: ${scoreGlow} 2s ease-in-out infinite;
  }
`;

const GameScreen = styled.div<{ isActive: boolean }>`
  width: 640px;
  height: 480px;
  background: ${props => props.isActive ? '#000' : '#111'};
  border: 3px solid #00ffff;
  border-radius: 8px;
  position: relative;
  overflow: hidden;
  margin-bottom: 20px;
  display: flex;
  align-items: center;
  justify-content: center;
  
  ${props => props.isActive && css`
    animation: ${pulse} 2s ease-in-out infinite;
  `}
`;

const GameCanvas = styled.canvas`
  width: 100%;
  height: 100%;
  background: #000;
  border-radius: 5px;
`;

const GameContent = styled.div`
  color: #00ffff;
  text-align: center;
  font-size: 1.2rem;
  padding: 20px;
  
  h3 {
    color: #ffff00;
    margin-bottom: 15px;
    font-size: 1.5rem;
  }
  
  p {
    margin: 10px 0;
    line-height: 1.6;
  }
`;

const ControlsContainer = styled.div`
  display: flex;
  flex-wrap: wrap;
  gap: 15px;
  justify-content: center;
  margin-bottom: 20px;
`;

const ControlButton = styled.button<{ variant?: 'primary' | 'secondary' | 'success' }>`
  background: ${props => 
    props.variant === 'primary' ? 'linear-gradient(45deg, #ff6b35, #f7931e)' :
    props.variant === 'success' ? 'linear-gradient(45deg, #00ff00, #00cc00)' :
    'linear-gradient(45deg, #00ffff, #0099cc)'};
  border: none;
  color: white;
  padding: 12px 20px;
  border-radius: 25px;
  font-family: 'Orbitron', monospace;
  font-weight: 600;
  font-size: 0.9rem;
  cursor: pointer;
  transition: all 0.3s ease;
  text-transform: uppercase;
  letter-spacing: 0.05em;

  &:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(255, 107, 53, 0.5);
  }

  &:active {
    transform: translateY(0);
  }

  &:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }
`;

const DebugPanel = styled.div`
  background: rgba(255, 0, 0, 0.1);
  border: 1px solid #ff0000;
  border-radius: 5px;
  padding: 10px;
  margin: 10px 0;
  color: #ff0000;
  font-family: 'Courier New', monospace;
  font-size: 0.8rem;
`;

const GameOverScreen = styled.div`
  background: rgba(255, 0, 0, 0.1);
  border: 2px solid #ff0000;
  border-radius: 10px;
  padding: 20px;
  margin-top: 20px;
  text-align: center;
  animation: ${gameOver} 2s infinite;
  
  h3 {
    margin-bottom: 15px;
    font-size: 1.8rem;
  }
  
  p {
    color: #00ffff;
    margin: 10px 0;
    font-size: 1.2rem;
  }
  
  .high-score-notice {
    background: rgba(255, 215, 0, 0.2);
    border: 1px solid #ffd700;
    border-radius: 5px;
    padding: 10px;
    margin: 10px 0;
    color: #ffd700;
    font-weight: bold;
    animation: ${scoreGlow} 1s ease-in-out infinite;
  }
`;

// Interfaces
interface Position {
  x: number;
  y: number;
}

interface SnakeGameState {
  snake: Position[];
  food: Position;
  direction: string;
  score: number;
  gameRunning: boolean;
  level: number;
  speed: number;
}

// Konstanten
const GRID_SIZE = 20;
const CANVAS_WIDTH = 640;
const CANVAS_HEIGHT = 480;
const GRID_WIDTH = CANVAS_WIDTH / GRID_SIZE;
const GRID_HEIGHT = CANVAS_HEIGHT / GRID_SIZE;
const INITIAL_SPEED = 150;
const SPEED_INCREMENT = 10;

// Colors
const colors = {
  background: '#000',
  snake: '#00ff00',
  snakeHead: '#00ff88',
  food: '#ff0000',
  text: '#00ffff'
};

// SnakeGame Component
const SnakeGame: React.FC = () => {
  const [gameStatus, setGameStatus] = useState<'idle' | 'playing' | 'paused' | 'gameover'>('idle');
  const [debugLogs, setDebugLogs] = useState<string[]>([]);
  const [showHighScore, setShowHighScore] = useState(false);
  
  const [snakeState, setSnakeState] = useState<SnakeGameState>({
    snake: [{ x: 10, y: 10 }],
    food: { x: 15, y: 15 },
    direction: 'RIGHT',
    score: 0,
    gameRunning: false,
    level: 1,
    speed: INITIAL_SPEED
  });
  
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const gameLoopRef = useRef<NodeJS.Timeout | undefined>(undefined);
  
  // User System Integration
  const { recordGameResult, isLoggedIn, currentUser } = useGameIntegration();

  // Debug-Log hinzuf√ºgen
  const addDebugLog = useCallback((message: string) => {
    const timestamp = new Date().toLocaleTimeString();
    setDebugLogs(prev => [...prev.slice(-4), `${timestamp}: ${message}`]);
    console.log(`üêç ${timestamp}: ${message}`);
  }, []); // Leeres dependency array!

  // Food generieren
  const generateFood = useCallback((snake: Position[]): Position => {
    // Collision-Check Funktion au√üerhalb der Schleife definieren
    const isPositionOccupied = (position: Position) => 
      snake.some(segment => segment.x === position.x && segment.y === position.y);

    let newFood: Position;
    do {
      newFood = {
        x: Math.floor(Math.random() * GRID_WIDTH),
        y: Math.floor(Math.random() * GRID_HEIGHT)
      };
    } while (isPositionOccupied(newFood)); // Funktion au√üerhalb der Schleife verwenden
  
    return newFood;
  }, []);

  // Spiel pausieren/fortsetzen
  const toggleGame = useCallback(() => {
    if (gameStatus === 'playing') {
      setGameStatus('paused');
      setSnakeState(prev => ({ ...prev, gameRunning: false }));
      addDebugLog('‚è∏Ô∏è Game paused');
    } else if (gameStatus === 'paused') {
      setGameStatus('playing');
      setSnakeState(prev => ({ ...prev, gameRunning: true }));
      addDebugLog('‚ñ∂Ô∏è Game resumed');
    }
  }, [gameStatus, addDebugLog]);

  // Keyboard-Handler
  useEffect(() => {
    const handleKeyPress = (event: KeyboardEvent) => {
       if (event.code === 'Space') { // ‚Üê event, nicht e
      event.preventDefault();     // ‚Üê event, nicht e
      toggleGame();
    }
      
      const key = event.key.toLowerCase();
      
      setSnakeState(prev => {
        switch (key) {
          case 'arrowup':
          case 'w':
            if (prev.direction !== 'DOWN') {
              addDebugLog('üêç Direction: UP');
              return { ...prev, direction: 'UP' };
            }
            break;
          case 'arrowdown':
          case 's':
            if (prev.direction !== 'UP') {
              addDebugLog('üêç Direction: DOWN');
              return { ...prev, direction: 'DOWN' };
            }
            break;
          case 'arrowleft':
          case 'a':
            if (prev.direction !== 'RIGHT') {
              addDebugLog('üêç Direction: LEFT');
              return { ...prev, direction: 'LEFT' };
            }
            break;
          case 'arrowright':
          case 'd':
            if (prev.direction !== 'LEFT') {
              addDebugLog('üêç Direction: RIGHT');
              return { ...prev, direction: 'RIGHT' };
            }
            break;
          case ' ':
            event.preventDefault();
            toggleGame();
            break;
        }
        return prev;
      });
    };

    window.addEventListener('keydown', handleKeyPress);
    return () => window.removeEventListener('keydown', handleKeyPress);
  }, [gameStatus, toggleGame, addDebugLog]);

  // Game ended - Score recording
  const gameEnded = useCallback((finalScore: number) => {
    setGameStatus('gameover');
  
    // Score an User-System senden
    if (isLoggedIn) {
      const { newHighScore } = recordGameResult('snake', finalScore);
      if (newHighScore) {
        setShowHighScore(true);
        addDebugLog(`üèÜ NEW HIGH SCORE: ${finalScore}!`);
      }
    }
  }, [isLoggedIn, recordGameResult, setShowHighScore, addDebugLog]); 

  // Snake Update-Logic
  const updateSnake = useCallback(() => {
    if (!snakeState.gameRunning) return;

    setSnakeState(prevState => {
      const newSnake = [...prevState.snake];
      const head = { ...newSnake[0] };

      // Bewegung basierend auf Richtung
      switch (prevState.direction) {
        case 'UP':    head.y -= 1; break;
        case 'DOWN':  head.y += 1; break;
        case 'LEFT':  head.x -= 1; break;
        case 'RIGHT': head.x += 1; break;
      }

      // Wand-Kollision pr√ºfen
      if (head.x < 0 || head.x >= GRID_WIDTH || head.y < 0 || head.y >= GRID_HEIGHT) {
        addDebugLog('üêç Wall collision - Game Over!');
        gameEnded(prevState.score);
        return { ...prevState, gameRunning: false };
      }

      // Selbst-Kollision pr√ºfen
      if (newSnake.some(segment => segment.x === head.x && segment.y === head.y)) {
        addDebugLog('üêç Self collision - Game Over!');
        gameEnded(prevState.score);
        return { ...prevState, gameRunning: false };
      }

      // Neuen Kopf hinzuf√ºgen
      newSnake.unshift(head);

      // Food gefressen?
      if (head.x === prevState.food.x && head.y === prevState.food.y) {
        const newScore = prevState.score + 10;
        const newFood = generateFood(newSnake);
        const newLevel = Math.floor(newScore / 100) + 1;
        const newSpeed = Math.max(50, INITIAL_SPEED - (newLevel - 1) * SPEED_INCREMENT);
        
        addDebugLog(`üçé Food eaten! Score: ${newScore}, Level: ${newLevel}`);
        
        return {
          ...prevState,
          snake: newSnake,
          food: newFood,
          score: newScore,
          level: newLevel,
          speed: newSpeed
        };
      } else {
        // Schwanz entfernen (normale Bewegung)
        newSnake.pop();
        return {
          ...prevState,
          snake: newSnake
        };
      }
    });
  }, [snakeState.gameRunning, generateFood, gameEnded, addDebugLog]);

  // Zeichnen
  const drawGame = useCallback(() => {
    const canvas = canvasRef.current;
    if (!canvas) return;
    
    const ctx = canvas.getContext('2d');
    if (!ctx) return;

    // Canvas leeren
    ctx.fillStyle = colors.background;
    ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

    // Snake zeichnen
    snakeState.snake.forEach((segment, index) => {
      // Kopf heller machen
      ctx.fillStyle = index === 0 ? colors.snakeHead : colors.snake;
      ctx.fillRect(
        segment.x * GRID_SIZE + 1,
        segment.y * GRID_SIZE + 1,
        GRID_SIZE - 2,
        GRID_SIZE - 2
      );
      
      // Highlight-Effekt f√ºr Kopf
      if (index === 0) {
        ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
        ctx.fillRect(
          segment.x * GRID_SIZE + 1,
          segment.y * GRID_SIZE + 1,
          GRID_SIZE - 2,
          4
        );
      }
    });

    // Food zeichnen
    ctx.fillStyle = colors.food;
    ctx.fillRect(
      snakeState.food.x * GRID_SIZE + 2,
      snakeState.food.y * GRID_SIZE + 2,
      GRID_SIZE - 4,
      GRID_SIZE - 4
    );

    // Food glow effect
    ctx.fillStyle = 'rgba(255, 0, 0, 0.3)';
    ctx.fillRect(
      snakeState.food.x * GRID_SIZE,
      snakeState.food.y * GRID_SIZE,
      GRID_SIZE,
      GRID_SIZE
    );

    // Score und Level auf Canvas
    ctx.fillStyle = colors.text;
    ctx.font = '20px Orbitron, monospace';
    ctx.fillText(`Score: ${snakeState.score}`, 10, 30);
    ctx.fillText(`Level: ${snakeState.level}`, 10, 55);
    ctx.fillText(`Length: ${snakeState.snake.length}`, 10, 80);
  }, [snakeState]);

  // Game-Loop
  useEffect(() => {
    if (gameStatus === 'playing' && snakeState.gameRunning) {
      const gameLoop = () => {
        updateSnake();
        drawGame();
        gameLoopRef.current = setTimeout(gameLoop, snakeState.speed);
      };

      gameLoopRef.current = setTimeout(gameLoop, snakeState.speed);

      return () => {
        if (gameLoopRef.current) {
          clearTimeout(gameLoopRef.current);
          gameLoopRef.current = undefined;
        }
      };
    }
  }, [gameStatus, snakeState.gameRunning, snakeState.speed, updateSnake, drawGame]);

  // Zeichnen wenn sich State √§ndert
  useEffect(() => {
    if (gameStatus !== 'idle') {
      drawGame();
    }
  }, [snakeState, gameStatus, drawGame]);

  // Neues Spiel starten
  const startNewGame = () => {
    const initialFood = generateFood([{ x: 10, y: 10 }]);
    
    setGameStatus('playing');
    setSnakeState({
      snake: [{ x: 10, y: 10 }],
      food: initialFood,
      direction: 'RIGHT',
      score: 0,
      gameRunning: true,
      level: 1,
      speed: INITIAL_SPEED
    });
    setShowHighScore(false);
    
    addDebugLog('üöÄ New Snake game started');
  };

  // Spiel zur√ºcksetzen
  const resetGame = () => {
    setGameStatus('idle');
    setSnakeState({
      snake: [{ x: 10, y: 10 }],
      food: { x: 15, y: 15 },
      direction: 'RIGHT',
      score: 0,
      gameRunning: false,
      level: 1,
      speed: INITIAL_SPEED
    });
    setShowHighScore(false);
    
    if (gameLoopRef.current) {
      clearTimeout(gameLoopRef.current);
      gameLoopRef.current = undefined;
    }
    
    addDebugLog('üîÑ Game reset');
  };

  // Render-Content
  const renderGameContent = () => {
    if (gameStatus === 'idle') {
      return (
        <GameContent>
          <h3>üêç Snake Game</h3>
          <p>Classic snake with modern graphics!</p>
          <p>üçé Eat food to grow and increase score</p>
          <p>‚ö° Speed increases every 100 points</p>
          <p>üéÆ Use WASD or Arrow Keys to control</p>
          <p>Press START GAME to begin!</p>
        </GameContent>
      );
    }

    if (gameStatus === 'paused') {
      return (
        <GameContent>
          <h3>‚è∏Ô∏è GAME PAUSED</h3>
          <p>Score: {snakeState.score}</p>
          <p>Level: {snakeState.level}</p>
          <p>Length: {snakeState.snake.length}</p>
          <p>Press RESUME to continue</p>
        </GameContent>
      );
    }

    if (gameStatus === 'gameover') {
      return (
        <GameOverScreen>
          <h3>üêç GAME OVER!</h3>
          <p>Final Score: {snakeState.score}</p>
          <p>Level Reached: {snakeState.level}</p>
          <p>Snake Length: {snakeState.snake.length}</p>
          {showHighScore && (
            <div className="high-score-notice">
              üèÜ NEW HIGH SCORE! üèÜ
            </div>
          )}
          {!isLoggedIn && (
            <p style={{ color: '#ff6b9d', fontSize: '0.9rem' }}>
              üí° Login to save your high scores!
            </p>
          )}
        </GameOverScreen>
      );
    }

    return null;
  };

  return (
    <SnakeGameContainer>
      <GameTitle>üêç Retro Snake Game v2.0</GameTitle>
      
      {/* Debug Panel */}
      <DebugPanel>
        <strong>üêõ DEBUG INFO:</strong><br/>
        Game Status: {gameStatus}<br/>
        Direction: {snakeState.direction}<br/>
        Snake Length: {snakeState.snake.length}<br/>
        Game Running: {snakeState.gameRunning ? '‚úÖ' : '‚ùå'}<br/>
        Speed: {snakeState.speed}ms<br/>
        User: {isLoggedIn ? currentUser?.username : 'Not logged in'}<br/>
        <strong>Recent Logs:</strong><br/>
        {debugLogs.map((log, i) => <div key={i}>{log}</div>)}
      </DebugPanel>

      {/* Game Info */}
      <GameInfo>
        <InfoCard>
          <h4>üéØ Score</h4>
          <span>{snakeState.score}</span>
        </InfoCard>
        <InfoCard>
          <h4>üìä Level</h4>
          <span>{snakeState.level}</span>
        </InfoCard>
        <InfoCard>
          <h4>üêç Length</h4>
          <span>{snakeState.snake.length}</span>
        </InfoCard>
        <InfoCard>
          <h4>‚ö° Speed</h4>
          <span>{((200 - snakeState.speed) / 10).toFixed(1)}x</span>
        </InfoCard>
      </GameInfo>

      {/* Game Screen */}
      <GameScreen isActive={gameStatus === 'playing'}>
        {gameStatus === 'playing' || gameStatus === 'paused' ? (
          <GameCanvas
            ref={canvasRef}
            width={CANVAS_WIDTH}
            height={CANVAS_HEIGHT}
          />
        ) : (
          renderGameContent()
        )}
      </GameScreen>

      {/* Controls */}
      <ControlsContainer>
        <ControlButton
          variant="success"
          onClick={startNewGame}
          disabled={gameStatus === 'playing'}
        >
          üöÄ {gameStatus === 'idle' ? 'Start Game' : 'New Game'}
        </ControlButton>
        
        <ControlButton
          onClick={toggleGame}
          disabled={gameStatus === 'idle' || gameStatus === 'gameover'}
        >
          {gameStatus === 'playing' ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Resume'}
        </ControlButton>
        
        <ControlButton
          variant="secondary"
          onClick={resetGame}
        >
          üîÑ Reset
        </ControlButton>
      </ControlsContainer>

      {/* Instructions */}
      <div style={{ color: '#00ffff', textAlign: 'center', fontSize: '0.9rem' }}>
        <p>üêç <strong>Goal:</strong> Eat food to grow and increase your score</p>
        <p>üéÆ <strong>Controls:</strong> WASD or Arrow Keys, Space to pause</p>
        <p>‚ö° <strong>Strategy:</strong> Plan your path to avoid hitting walls or yourself</p>
        <p>üèÜ <strong>Challenge:</strong> Speed increases every level!</p>
      </div>
    </SnakeGameContainer>
  );
};

export default SnakeGame;