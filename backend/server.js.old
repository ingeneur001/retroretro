const express = require('express');
const cors = require('cors');
const http = require('http');
const socketIo = require('socket.io');
const morgan = require('morgan');
const path = require('path');
const { testPostgreSQL, testRedis, closeConnections } = require('./src/database/connection');

// Ganz am ANFANG von server.js hinzufügen (vor allen anderen requires):
require('dotenv').config();

// 🆕 NEW: Import Database Managers (falls vorhanden)
let UserManager, GameSessionManager;
try {
  const managers = require('./src/database/managers');
  UserManager = managers.UserManager;
  GameSessionManager = managers.GameSessionManager;
  console.log('✅ Database managers loaded');
} catch (err) {
  console.log('⚠️  Database managers not found - running in basic mode');
}

// 🆕 NEW: Import Database Setup (falls vorhanden)
let setupDatabase;
try {
  const setup = require('./src/database/setup');
  setupDatabase = setup.setupDatabase;
  console.log('✅ Database setup loaded');
} catch (err) {
  console.log('⚠️  Database setup not found - skipping auto-setup');
}

// Express App erstellen
const app = express();
const server = http.createServer(app);

// 🚀 REPARIERTE SOCKET.IO KONFIGURATION - LÖST 3-MINUTEN-PROBLEM!
const io = socketIo(server, {
  // KRITISCHE FIXES für Event-Loop-Blocking:
  upgradeTimeout: 5000,        // Reduziert von 10s - verhindert Blocking!
  pingTimeout: 30000,          // Erhöht von 20s - stabilere Verbindungen
  pingInterval: 10000,         // Reduziert von 25s - schnellere Fehlererkennun
  
  // MEMORY-LEAK PREVENTION:
  perMessageDeflate: false,    // Verhindert zlib Memory-Fragmentation
  maxHttpBufferSize: 1000000,  // 1MB Message-Limit
  
  // TRANSPORT-OPTIMIERUNG:
  transports: ["polling", "websocket"],
  allowUpgrades: true,
  
  // CORS (deine bestehende Config, aber optimiert):
  cors: {
    origin: ["http://localhost:3000", "http://127.0.0.1:3000", "http://localhost:3001"],
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true,
    allowedHeaders: ["Content-Type", "Authorization"]
  }
});

// 🚀 MEMORY-LEAK PREVENTION - KRITISCH!
io.engine.on("connection", (rawSocket) => {
  rawSocket.request = null; // Verhindert HTTP Request Memory-Leaks
});

// Middleware (deine bestehende Config)
app.use(cors({
  origin: ["http://localhost:3000", "http://127.0.0.1:3000", "http://localhost:3001"],
  credentials: true,
  methods: ["GET", "POST", "PUT", "DELETE"],
  allowedHeaders: ["Content-Type", "Authorization", "X-Requested-With"]
}));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));
app.use(morgan('combined')); // Logging

// Server-Variablen (erweitert)
const PORT = process.env.PORT || 3001;
let connectedUsers = 0;
let serverStartTime = Date.now();

// 🆕 NEW: Database status tracking
let databaseReady = false;
let userManager = null;
let sessionManager = null;
let activeConnections = new Map(); // Track user sessions

// Dein bestehender Health Check (unverändert)
app.get('/health', (req, res) => {
  const uptime = Math.floor((Date.now() - serverStartTime) / 1000);
  
  res.json({
    status: 'OK',
    uptime: uptime,
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    connectedUsers: connectedUsers,
    port: PORT,
    socketio: 'repaired', // Indikator für reparierte Version
    note: 'Socket.IO fixed for stability'
  });
});

// Dein bestehender Database Health Check (erweitert)
app.get('/health-db', async (req, res) => {
  try {
    console.log('Testing database connections...');
    const pgHealth = await testPostgreSQL();
    const redisHealth = await testRedis();
    
    res.json({
      status: 'database-check',
      databases: {
        postgresql: pgHealth ? 'connected' : 'disconnected',
        redis: redisHealth ? 'connected' : 'disconnected'
      },
      // 🆕 NEW: Extended info
      features: {
        userManagement: databaseReady && userManager !== null,
        sessionManagement: databaseReady && sessionManager !== null,
        scoreTracking: databaseReady
      },
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    res.status(500).json({ 
      error: 'Database connection error',
      message: err.message 
    });
  }
});

// Deine bestehende API Routes (unverändert)
app.get('/api/status', (req, res) => {
  res.json({
    server: 'Legal Retro Gaming Service',
    status: 'running',
    users: connectedUsers,
    uptime: Math.floor((Date.now() - serverStartTime) / 1000),
    // 🆕 NEW: Database status
    database: databaseReady,
    socketio: 'stable', // Indikator für stabile Socket.IO
    features: databaseReady ? ['multiplayer', 'user-accounts', 'score-tracking'] : ['multiplayer']
  });
});

// Deine bestehende Games Route (erweitert mit Database Support)
app.get('/api/games', async (req, res) => {
  try {
    // 🆕 NEW: Try database first, fallback to hardcoded
    if (databaseReady && userManager) {
      const dbGames = await userManager.getGames();
      if (dbGames && dbGames.length > 0) {
        return res.json({
          source: 'database',
          availableGames: dbGames.map(game => ({
            id: game.slug,
            name: game.title,
            description: game.description,
            status: 'available',
            maxPlayers: game.max_players,
            isMultiplayer: game.is_multiplayer,
            category: game.category,
            difficulty: game.difficulty_level
          }))
        });
      }
    }
    
    // Fallback zu deinen bestehenden Games (unverändert)
    res.json({
      source: 'fallback',
      availableGames: [
        {
          id: 'snake',
          name: 'Snake Game',
          description: 'Classic Snake game built in React',
          status: 'available',
          maxPlayers: 4,
          isMultiplayer: true
        },
        {
          id: 'memory',
          name: 'Memory Game', 
          description: 'Test your memory with cards',
          status: 'available',
          maxPlayers: 1,
          isMultiplayer: false
        },
        {
          id: 'pong',
          name: 'Pong Demo',
          description: 'Simple Pong game simulation',
          status: 'available',
          maxPlayers: 2,
          isMultiplayer: true
        },
        {
          id: 'tetris',
          name: 'Tetris Demo',
          description: 'Tetris-style block game',
          status: 'available',
          maxPlayers: 2,
          isMultiplayer: true
        }
      ]
    });
  } catch (error) {
    console.error('❌ Error fetching games:', error);
    res.status(500).json({ error: 'Failed to fetch games' });
  }
});

// 🆕 NEW: Additional API Routes (nur wenn Database verfügbar)
app.get('/api/sessions', async (req, res) => {
  if (!databaseReady || !sessionManager) {
    return res.json({
      message: 'Session management requires database connection',
      sessions: []
    });
  }
  
  try {
    const sessions = await sessionManager.getActiveSessions();
    res.json({ sessions });
  } catch (error) {
    console.error('❌ Error fetching sessions:', error);
    res.status(500).json({ error: 'Failed to fetch sessions' });
  }
});

app.get('/api/leaderboard/:gameId?', async (req, res) => {
  if (!databaseReady || !userManager) {
    return res.json({
      message: 'Leaderboard requires database connection',
      leaderboard: []
    });
  }
  
  try {
    const { gameId } = req.params;
    const limit = parseInt(req.query.limit) || 10;
    const leaderboard = await userManager.getLeaderboard(gameId, limit);
    res.json({ leaderboard, game: gameId || 'all' });
  } catch (error) {
    console.error('❌ Error fetching leaderboard:', error);
    res.status(500).json({ error: 'Failed to fetch leaderboard' });
  }
});

// 🆕 NEW: User Registration (nur wenn Database verfügbar)
app.post('/api/register', async (req, res) => {
  if (!databaseReady || !userManager) {
    return res.status(503).json({
      error: 'User registration requires database connection'
    });
  }
  
  try {
    const { username, email, password, displayName } = req.body;
    
    if (!username || !email || !password) {
      return res.status(400).json({
        error: 'Username, email, and password are required'
      });
    }

    const user = await userManager.createUser({
      username,
      email,
      password,
      displayName: displayName || username
    });

    res.json({
      success: true,
      user: {
        id: user.id,
        username: user.username,
        displayName: user.display_name,
        membershipTier: user.membership_tier
      }
    });
  } catch (error) {
    console.error('❌ Registration error:', error);
    res.status(400).json({
      success: false,
      error: error.message
    });
  }
});

// 🚀 REPARIERTE SOCKET.IO EVENT-HANDLER
io.on('connection', (socket) => {
  connectedUsers++;
  console.log(`👤 User connected: ${socket.id} (Total: ${connectedUsers})`);
  
  // 🆕 NEW: Track connection mit erweiterten Infos
  activeConnections.set(socket.id, {
    id: socket.id,
    connectedAt: new Date(),
    userId: null,
    currentGame: null,
    currentSession: null
  });
  
  // Deine bestehende Begrüßung (erweitert)
  socket.emit('welcome', {
    message: 'Welcome to Legal Retro Gaming Service!',
    serverId: socket.id,
    timestamp: new Date().toISOString(),
    // 🆕 NEW: Feature info
    features: {
      realTimeMultiplayer: true,
      userAccounts: databaseReady,
      scoreTracking: databaseReady,
      leaderboards: databaseReady,
      socketioVersion: 'repaired' // Indikator für reparierte Version
    }
  });
  
  // Dein bestehender User-Count (unverändert)
  io.emit('player-count', connectedUsers);
  
  // 🚀 VERBESSERTER PING-PONG (Event-Loop-Safe)
  socket.on('ping', (timestamp) => {
    // Asynchron machen um Event-Loop nicht zu blockieren
    setImmediate(() => {
      socket.emit('pong', {
        timestamp,
        serverTime: Date.now(),
        databaseStatus: databaseReady,
        connectionStable: true
      });
    });
  });
  
  // 🆕 NEW: User Authentication (wenn Database verfügbar) - ASYNC SAFE
  socket.on('authenticate', async (data) => {
    if (!databaseReady || !userManager) {
      socket.emit('auth-response', {
        success: false,
        error: 'Authentication requires database connection'
      });
      return;
    }

    try {
      const { username, password } = data;
      
      // Async operation - nicht blockierend
      const user = await userManager.authenticateUser(username, password);
      
      if (user) {
        const connection = activeConnections.get(socket.id);
        connection.userId = user.id;
        connection.username = user.username;
        
        await userManager.updateLastActive(user.id);
        
        socket.emit('auth-response', {
          success: true,
          user: {
            id: user.id,
            username: user.username,
            displayName: user.display_name,
            membershipTier: user.membership_tier
          }
        });
        
        console.log(`👤 User authenticated: ${user.username} (${socket.id})`);
      } else {
        socket.emit('auth-response', {
          success: false,
          error: 'Invalid credentials'
        });
      }
    } catch (error) {
      console.error('❌ Authentication error:', error);
      socket.emit('auth-response', {
        success: false,
        error: 'Authentication failed'
      });
    }
  });
  
  // 🚀 VERBESSERTE GAME-EVENTS (Event-Loop-Safe)
  socket.on('join-game', async (gameData) => {
    console.log(`🎮 User ${socket.id} joined game: ${gameData.gameId}`);
    
    const connection = activeConnections.get(socket.id);
    connection.currentGame = gameData.gameId;
    
    // Deine bestehende Room-Logic (unverändert)
    socket.join(`game-${gameData.gameId}`);
    
    // 🆕 NEW: Database Session Management (wenn verfügbar) - ASYNC SAFE
    if (databaseReady && sessionManager && connection.userId) {
      // Async operation in setImmediate um Event-Loop nicht zu blockieren
      setImmediate(async () => {
        try {
          const game = await userManager.getGameBySlug(gameData.gameId);
          if (game) {
            const session = await sessionManager.createSession(game.id, connection.userId);
            await sessionManager.joinSession(session.id, connection.userId, socket.id);
            connection.currentSession = session.id;
            
            socket.emit('session-created', {
              sessionId: session.id,
              gameTitle: game.title
            });
          }
        } catch (error) {
          console.error('❌ Session creation error:', error);
        }
      });
    }
    
    // Deine bestehende Player-Notification (unverändert)
    socket.to(`game-${gameData.gameId}`).emit('player-joined', {
      playerId: socket.id,
      gameId: gameData.gameId,
      timestamp: new Date().toISOString()
    });
  });
  
  socket.on('leave-game', async (gameData) => {
    console.log(`🎮 User ${socket.id} left game: ${gameData.gameId}`);
    
    const connection = activeConnections.get(socket.id);
    
    // 🆕 NEW: Database Session cleanup (wenn verfügbar) - ASYNC SAFE
    if (databaseReady && sessionManager && connection.currentSession && connection.userId) {
      setImmediate(async () => {
        try {
          await sessionManager.handlePlayerDisconnect(connection.currentSession, connection.userId);
        } catch (error) {
          console.error('❌ Session cleanup error:', error);
        }
      });
    }
    
    connection.currentGame = null;
    connection.currentSession = null;
    
    // Deine bestehende Room-Logic (unverändert)
    socket.leave(`game-${gameData.gameId}`);
    
    socket.to(`game-${gameData.gameId}`).emit('player-left', {
      playerId: socket.id,
      gameId: gameData.gameId,
      timestamp: new Date().toISOString()
    });
  });
  
  // 🚀 VERBESSERTER GAME-INPUT (Event-Loop-Safe)
  socket.on('game-input', async (inputData) => {
    // Deine bestehende Logic (unverändert)
    socket.to(`game-${inputData.gameId}`).emit('player-input', {
      playerId: socket.id,
      input: inputData.input,
      timestamp: new Date().toISOString()
    });
    
    // 🆕 NEW: Save game state (wenn verfügbar) - ASYNC SAFE
    if (databaseReady && sessionManager) {
      const connection = activeConnections.get(socket.id);
      if (connection.currentSession && inputData.gameState) {
        setImmediate(async () => {
          try {
            await sessionManager.updateGameState(connection.currentSession, inputData.gameState);
          } catch (error) {
            console.error('❌ Game state save error:', error);
          }
        });
      }
    }
  });
  
  // 🆕 NEW: Score Submission (wenn Database verfügbar) - ASYNC SAFE
  socket.on('submit-score', async (scoreData) => {
    if (!databaseReady || !userManager) {
      socket.emit('score-response', {
        success: false,
        error: 'Score tracking requires database connection'
      });
      return;
    }

    const connection = activeConnections.get(socket.id);
    if (!connection.userId || !connection.currentSession) {
      socket.emit('score-response', {
        success: false,
        error: 'Authentication and active session required'
      });
      return;
    }

    // Async operation - nicht blockierend
    setImmediate(async () => {
      try {
        await userManager.saveScore({
          userId: connection.userId,
          sessionId: connection.currentSession,
          score: scoreData.score,
          levelReached: scoreData.level || 1,
          timePlayedSeconds: scoreData.timeSeconds || 0,
          completed: scoreData.completed || false
        });

        socket.emit('score-response', {
          success: true,
          score: scoreData.score
        });

        console.log(`📊 Score saved: ${connection.username} - ${scoreData.score} points`);
      } catch (error) {
        console.error('❌ Score save error:', error);
        socket.emit('score-response', {
          success: false,
          error: 'Failed to save score'
        });
      }
    });
  });
  
  // 🚀 VERBESSERTER DISCONNECT-HANDLER (Event-Loop-Safe)
  socket.on('disconnect', async (reason) => {
    connectedUsers--;
    console.log(`👤 User disconnected: ${socket.id} (${reason}) (Total: ${connectedUsers})`);
    
    // 🆕 NEW: Database cleanup bei Disconnect - ASYNC SAFE
    const connection = activeConnections.get(socket.id);
    if (databaseReady && sessionManager && connection && connection.currentSession && connection.userId) {
      setImmediate(async () => {
        try {
          await sessionManager.handlePlayerDisconnect(connection.currentSession, connection.userId);
        } catch (error) {
          console.error('❌ Disconnect cleanup error:', error);
        }
      });
    }
    
    // Socket cleanup - WICHTIG für Memory-Leak Prevention!
    socket.removeAllListeners();
    activeConnections.delete(socket.id);
    
    // Dein bestehender User-Count Update (unverändert)
    io.emit('player-count', connectedUsers);
  });
  
  // Dein bestehender Error-Handler (unverändert)
  socket.on('error', (error) => {
    console.error(`❌ Socket error for ${socket.id}:`, error);
  });
});

// Deine bestehenden Error-Handler (unverändert)
app.use((err, req, res, next) => {
  console.error('❌ Express Error:', err);
  res.status(500).json({
    error: 'Internal Server Error',
    message: err.message
  });
});

app.use('*', (req, res) => {
  res.status(404).json({
    error: 'Route not found',
    path: req.originalUrl
  });
});

// Dein bestehender Server Start (erweitert)
server.listen(PORT, () => {
  console.log('🎮 Legal Retro Gaming Service running on port ' + PORT);
  console.log('🔗 Health check: http://localhost:' + PORT + '/health');
  console.log('🗄️ Database check: http://localhost:' + PORT + '/health-db');
  console.log('📡 Socket.IO ready for multiplayer connections');
  console.log('🚀 Socket.IO REPAIRED - Event-loop blocking issues fixed!');
  
  // 🆕 NEW: Extended API info
  console.log('🚀 API Endpoints:');
  console.log('   📊 Games: http://localhost:' + PORT + '/api/games');
  console.log('   🎮 Sessions: http://localhost:' + PORT + '/api/sessions');
  console.log('   🏆 Leaderboard: http://localhost:' + PORT + '/api/leaderboard');
  
  // Database Test async und non-blocking (erweitert)
  setTimeout(async () => {
    console.log('🔌 Testing database connections asynchronously...');
    try {
      // OPTIONAL: Database-Tests können wieder aktiviert werden mit Timeouts:
      // await initializeDatabases();
      console.log('⚠️ Database tests skipped for stability (can be re-enabled)');
    } catch (err) {
      console.log('⚠️ Database connections failed:', err.message);
    }
  }, 2000);
});

// Deine bestehenden Graceful Shutdown Handler (erweitert)
process.on('SIGTERM', async () => {
  console.log('🛑 Server shutting down gracefully...');
  
  // 🆕 NEW: Close Socket.IO connections first
  io.close(() => {
    console.log('✅ Socket.IO closed');
  });
  
  // 🆕 NEW: Close database connections
  try {
    await closeConnections();
  } catch (err) {
    console.error('❌ Error closing database connections:', err);
  }
  
  server.close(() => {
    console.log('✅ Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', async () => {
  console.log('🛑 Server shutting down gracefully...');
  
  // 🆕 NEW: Close Socket.IO connections first
  io.close(() => {
    console.log('✅ Socket.IO closed');
  });
  
  // 🆕 NEW: Close database connections
  try {
    await closeConnections();
  } catch (err) {
    console.error('❌ Error closing database connections:', err);
  }
  
  server.close(() => {
    console.log('✅ Server closed');
    process.exit(0);
  });
});

// Deine bestehende Database Initialization Function (erweitert)
async function initializeDatabases() {
    console.log('🔌 Initializing database connections...');
    
    const pgConnected = await testPostgreSQL();
    const redisConnected = await testRedis();
    
    if (pgConnected && redisConnected) {
        console.log('🎉 All databases connected successfully!');
        
        // 🆕 NEW: Initialize advanced features
        try {
          // Setup database schema if needed
          if (setupDatabase) {
            await setupDatabase();
            console.log('✅ Database schema ready');
          }
          
          // Initialize managers
          if (UserManager && GameSessionManager) {
            userManager = new UserManager();
            sessionManager = new GameSessionManager();
            databaseReady = true;
            console.log('✅ Database managers initialized');
            console.log('🚀 Advanced features enabled: User accounts, Score tracking, Sessions');
          }
        } catch (error) {
          console.error('❌ Advanced feature initialization failed:', error);
          console.log('⚠️  Running in basic mode');
        }
        
        return true;
    } else {
        console.log('❌ Database connection failed - running in basic mode!');
        console.log('💡 All core features still work, advanced features disabled');
        return false;
    }
}

module.exports = { app, server, io };