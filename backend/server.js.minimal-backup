const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');

console.log('ðŸš€ Starting RetroRetro Backend...');

// Create Express application
const app = express();

// Create HTTP server
const server = http.createServer(app);

// Configure CORS
const corsOptions = {
  origin: [
    "http://localhost:3000",
    "http://127.0.0.1:3000"
  ],
  methods: ["GET", "POST", "PUT", "DELETE"],
  credentials: true,
  allowedHeaders: ["Content-Type", "Authorization"]
};

app.use(cors(corsOptions));
app.use(express.json());
app.use(express.urlencoded({ extended: true }));

// Basic API Routes
app.get('/', (req, res) => {
  res.json({
    message: 'RetroRetro Backend API',
    status: 'running',
    version: '1.0.0',
    timestamp: new Date().toISOString()
  });
});

app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    service: 'RetroRetro Backend',
    socketIO: 'enabled',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

// Socket.IO Configuration
const io = new Server(server, {
  cors: corsOptions,
  transports: ['websocket', 'polling'],
  pingTimeout: 60000,
  pingInterval: 25000,
  allowEIO3: true
});

// Socket Status Endpoint (after io is defined)
app.get('/socket-status', (req, res) => {
  res.json({
    socketIO: 'active',
    connectedClients: io.engine.clientsCount,
    transports: ['websocket', 'polling'],
    timestamp: new Date().toISOString()
  });
});

// Socket.IO Connection Handling
io.on('connection', (socket) => {
  console.log(`ðŸ”Œ Client connected: ${socket.id}`);
  
  // Welcome message
  socket.emit('welcome', {
    message: 'Connected to RetroRetro Backend',
    socketId: socket.id,
    timestamp: new Date().toISOString()
  });
  
  // Test events
  socket.on('ping', (data) => {
    console.log('ðŸ“¡ Ping received:', data);
    socket.emit('pong', {
      message: 'Pong from server',
      timestamp: new Date().toISOString(),
      received: data
    });
  });
  
  socket.on('test', (data) => {
    console.log('ðŸ§ª Test event:', data);
    socket.emit('test-response', {
      success: true,
      message: 'Test successful',
      received: data,
      timestamp: new Date().toISOString()
    });
  });
  
  // Room management
  socket.on('room:create', (data) => {
    const roomId = `room_${Date.now()}_${Math.random().toString(36).substr(2, 6)}`;
    socket.join(roomId);
    console.log(`ðŸ  Room created: ${roomId} by ${socket.id}`);
    
    socket.emit('room:created', {
      success: true,
      roomId: roomId,
      message: 'Room created successfully'
    });
  });
  
  socket.on('room:join', (data) => {
    const roomId = typeof data === 'object' ? data.roomId : data;
    socket.join(roomId);
    console.log(`ðŸšª ${socket.id} joined room: ${roomId}`);
    
    socket.emit('room:joined', {
      success: true,
      roomId: roomId,
      message: `Joined room ${roomId}`
    });
    
    socket.to(roomId).emit('player:joined', {
      playerId: socket.id,
      roomId: roomId
    });
  });
  
  socket.on('room:leave', (data) => {
    const roomId = typeof data === 'object' ? data.roomId : data;
    socket.leave(roomId);
    console.log(`ðŸšª ${socket.id} left room: ${roomId}`);
    
    socket.emit('room:left', {
      success: true,
      roomId: roomId,
      message: `Left room ${roomId}`
    });
    
    socket.to(roomId).emit('player:left', {
      playerId: socket.id,
      roomId: roomId
    });
  });
  
  // Chat system
  socket.on('chat:message', (data) => {
    console.log('ðŸ’¬ Chat message:', data);
    
    if (data.roomId) {
      io.to(data.roomId).emit('chat:received', {
        id: `msg_${Date.now()}`,
        senderId: socket.id,
        senderName: data.senderName || 'Anonymous',
        message: data.message,
        roomId: data.roomId,
        timestamp: new Date().toISOString()
      });
    }
  });
  
  // Game events
  socket.on('game:action', (data) => {
    console.log('ðŸŽ® Game action:', data);
    
    if (data.roomId) {
      socket.to(data.roomId).emit('game:update', {
        playerId: socket.id,
        action: data.action,
        data: data.data,
        roomId: data.roomId,
        timestamp: new Date().toISOString()
      });
    }
  });
  
  // Disconnect handling
  socket.on('disconnect', (reason) => {
    console.log(`âŒ Client disconnected: ${socket.id} (${reason})`);
  });
  
  // Error handling
  socket.on('error', (error) => {
    console.error(`ðŸš¨ Socket error for ${socket.id}:`, error);
  });
});

// Error handling for Socket.IO server
io.engine.on('connection_error', (err) => {
  console.error('ðŸš¨ Socket.IO connection error:', err);
});

// Start the server
const PORT = process.env.PORT || 3001;
const HOST = process.env.HOST || 'localhost';

server.listen(PORT, HOST, () => {
  console.log('\nðŸŽ‰ RetroRetro Backend Server Started!');
  console.log('=' * 50);
  console.log(`ðŸ“ Server URL: http://${HOST}:${PORT}`);
  console.log(`ðŸ¥ Health Check: http://${HOST}:${PORT}/health`);
  console.log(`ðŸ“Š Socket Status: http://${HOST}:${PORT}/socket-status`);
  console.log(`ðŸ”Œ Socket.IO: ws://${HOST}:${PORT}/socket.io/`);
  console.log('=' * 50);
  console.log('âœ… Ready for connections!');
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('ðŸ›‘ SIGTERM received. Shutting down gracefully...');
  server.close(() => {
    console.log('âœ… Server closed');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('\nðŸ›‘ SIGINT received. Shutting down gracefully...');
  server.close(() => {
    console.log('âœ… Server closed');
    process.exit(0);
  });
});

// Export for testing
module.exports = { app, server, io };
